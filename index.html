<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>9x9 Grid Master: Save & Load</title>
    <style>
        body {
            background-color: #121212;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }

        #top-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 5px;
            width: 95%;
            max-width: 450px;
        }

        h2 { margin: 2px; color: #eee; font-size: 1.3rem; }
        
        #status {
            font-size: 13px;
            color: #aaa;
            height: 18px;
            margin-bottom: 5px;
            text-align: center;
        }

        /* ZORLUK SE√áƒ∞Cƒ∞ */
        #difficulty-bar {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            width: 100%;
            padding: 5px 2px;
            margin-bottom: 5px;
            scrollbar-width: none;
        }
        #difficulty-bar::-webkit-scrollbar { display: none; }

        .diff-btn {
            background: #222;
            color: #888;
            border: 1px solid #444;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .diff-btn.active {
            background: #448AFF;
            color: white;
            border-color: #448AFF;
            box-shadow: 0 0 8px rgba(68, 138, 255, 0.4);
        }

        /* KONTROLLER & MEN√ú */
        #controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            margin-bottom: 5px;
        }

        .action-btn { 
            font-weight: bold; border: none; 
            padding: 6px 10px; border-radius: 12px; font-size: 12px;
            color: #333; cursor: pointer;
        }
        .action-btn:disabled { opacity: 0.4; filter: grayscale(1); cursor: not-allowed; }
        
        #undo-btn { background-color: #ff5252; color: white; }
        #hint-btn { background-color: #ffd740; }
        #magnet-btn { background-color: #69f0ae; }
        #joker-btn { background-color: #e040fb; color: white; }
        
        /* DATA BUTTONS (Save/Load) */
        .data-btn {
            background: #333; color: #ccc; border: 1px solid #555;
            padding: 6px 10px; border-radius: 12px; font-size: 12px; cursor: pointer;
        }
        .data-btn:hover { background: #444; color: white; }

        #magnet-btn.mode-active {
            animation: pulse 1s infinite;
            border: 2px solid white;
            box-shadow: 0 0 15px #69f0ae;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* OYUN ALANI */
        #game-board {
            display: grid;
            width: 92vw; height: 92vw;
            max-width: 420px; max-height: 420px;
            gap: 1px;
            background-color: #222;
            padding: 4px;
            border-radius: 8px;
            border: 2px solid #444;
            position: relative;
        }

        .remove-cursor { cursor: alias !important; }
        .remove-cursor .cell.filled:not(.locked):not(.prefill) {
            opacity: 0.8; border: 2px dashed #ff5252;
        }

        .cell {
            background-color: #2a2a2a; border-radius: 2px; width: 100%; height: 100%;
            transition: background-color 0.1s, transform 0.1s;
        }
        .filled { border: 1px solid rgba(255,255,255,0.2); }
        .cell.locked, .cell.prefill {
            filter: brightness(0.7); border-color: #ffffff33;
            background-image: repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(0,0,0,0.2) 3px, rgba(0,0,0,0.2) 6px);
            pointer-events: none;
        }
        .cell.preview {
            background-color: rgba(255, 255, 255, 0.4) !important;
            border: 1px solid white; z-index: 10;
        }

        #pieces-tray {
            margin-top: 10px; width: 95%; height: 100px;
            background-color: #1e1e1e; border-radius: 12px;
            display: flex; align-items: center; padding: 10px; gap: 15px;
            overflow-x: auto; box-shadow: inset 0 0 10px #000;
        }

        .piece-preview {
            display: grid; gap: 1px; padding: 10px; 
            background: rgba(255,255,255,0.05); border-radius: 5px;
            touch-action: none; flex-shrink: 0; transition: opacity 0.3s;
        }
        .dragging {
            position: fixed; pointer-events: none; z-index: 1000;
            opacity: 0.9; transform: scale(1.1); filter: drop-shadow(0 15px 30px rgba(0,0,0,0.6));
        }

        /* --- MODALS --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; align-items: center; justify-content: center; z-index: 2000;
        }
        .modal-content {
            background: #1e1e1e; padding: 20px; border-radius: 12px;
            text-align: center; border: 1px solid #444; width: 85%; max-width: 400px;
        }
        
        /* DATA MODAL */
        #data-textarea {
            width: 100%; height: 100px; background: #111; color: #0f0;
            border: 1px solid #333; font-family: monospace; font-size: 11px;
            margin: 10px 0; resize: none; padding: 5px;
        }
        .file-input { display: none; }
        
        /* JOKER STYLES */
        #joker-grid {
            display: grid; grid-template-columns: repeat(5, 35px); grid-template-rows: repeat(5, 35px);
            gap: 2px; margin: 15px auto; background: #222; padding: 5px; border-radius: 4px;
        }
        .j-cell { width: 35px; height: 35px; background: #333; cursor: pointer; border: 1px solid #444; }
        .j-cell.selected { background: #e040fb; border-color: #fff; }

        .modal-btn { padding: 8px 16px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; margin: 5px; }
        .create-btn { background: #e040fb; color: white; }
        .cancel-btn { background: #444; color: #ccc; }
        .save-btn { background: #448AFF; color: white; }
        .load-btn { background: #69f0ae; color: #222; }

        .c-0 { background-color: #FF5252; } .c-1 { background-color: #448AFF; } .c-2 { background-color: #69F0AE; }
        .c-3 { background-color: #E040FB; } .c-4 { background-color: #FFD740; } .c-5 { background-color: #FF6E40; }
        .c-god { background: linear-gradient(135deg, #ff00cc, #333399); } 

    </style>
</head>
<body>

    <div id="top-bar">
        <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
            <h2>Grid Master</h2>
            <div>
                <button class="data-btn" onclick="openSaveModal()">üíæ Kaydet</button>
                <button class="data-btn" onclick="openLoadModal()">üìÇ Y√ºkle</button>
            </div>
        </div>
        
        <div id="status">Zorluk se√ß ve ba≈üla.</div>
        
        <div id="difficulty-bar">
            <button class="diff-btn" onclick="setDifficulty('easy', this)">Kolay (6x6)</button>
            <button class="diff-btn" onclick="setDifficulty('medium', this)">Orta (7x7)</button>
            <button class="diff-btn active" onclick="setDifficulty('med-hard', this)">Orta-√úst (8x8)</button>
            <button class="diff-btn" onclick="setDifficulty('hard', this)">Zor (9x9)</button>
            <button class="diff-btn" onclick="setDifficulty('master', this)">Usta (10x10)</button>
            <button class="diff-btn" onclick="setDifficulty('legend', this)">Efsane (11x11)</button>
            <button class="diff-btn" onclick="setDifficulty('god', this)" style="color:#e040fb;">???? (12x12)</button>
        </div>

        <div id="controls">
            <button id="undo-btn" class="action-btn" onclick="undoMove()">‚Ü∫ (3)</button>
            <button id="hint-btn" class="action-btn" onclick="useHint()">üí° (3)</button>
            <button id="magnet-btn" class="action-btn" onclick="toggleRemoveMode()">üß≤ (1)</button>
            <button id="joker-btn" class="action-btn" onclick="openJokerModal()">‚òÖ (1)</button>
        </div>
    </div>

    <div id="game-board"></div>
    <div id="pieces-tray"></div>

    <div id="joker-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Joker Par√ßa</h3>
            <div id="joker-grid"></div>
            <div id="joker-status" style="height:15px; color:#ff5252; font-size:11px;"></div>
            <button class="modal-btn cancel-btn" onclick="closeModal('joker-modal')">ƒ∞ptal</button>
            <button class="modal-btn create-btn" onclick="createJokerPiece()">√úret</button>
        </div>
    </div>

    <div id="save-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Oyunu Kaydet</h3>
            <textarea id="export-area" readonly></textarea>
            <div>
                <button class="modal-btn save-btn" onclick="copyToClipboard()">Kopyala</button>
                <button class="modal-btn save-btn" onclick="downloadSaveFile()">ƒ∞ndir (.json)</button>
                <button class="modal-btn cancel-btn" onclick="closeModal('save-modal')">Kapat</button>
            </div>
        </div>
    </div>

    <div id="load-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Oyun Y√ºkle</h3>
            <p style="font-size:12px; color:#aaa">JSON kodunu yapƒ±≈ütƒ±r veya dosya se√ß.</p>
            <textarea id="import-area" placeholder='{"config":...}'></textarea>
            <input type="file" id="file-upload" class="file-input" accept=".json" onchange="handleFileUpload(this)">
            <button class="modal-btn" style="background:#333; border:1px solid #555; color:#ccc" onclick="document.getElementById('file-upload').click()">Dosya Se√ß</button>
            <div style="margin-top:10px;">
                <button class="modal-btn load-btn" onclick="loadFromText()">Y√ºkle & Ba≈ülat</button>
                <button class="modal-btn cancel-btn" onclick="closeModal('load-modal')">ƒ∞ptal</button>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL DEƒûƒ∞≈ûKENLER ---
        let currentGridSize = 8;
        let cellPixelSize = 0; 
        let boardState = [];
        const COLORS = ['c-0', 'c-1', 'c-2', 'c-3', 'c-4', 'c-5'];
        
        let currentLevelKey = 'med-hard';
        const LEVELS = {
            'easy':     { size: 6,  prefillMin: 0.15, prefillMax: 0.25 },
            'medium':   { size: 7,  prefillMin: 0.12, prefillMax: 0.20 },
            'med-hard': { size: 8,  prefillMin: 0.10, prefillMax: 0.18 },
            'hard':     { size: 9,  prefillMin: 0.08, prefillMax: 0.15 },
            'master':   { size: 10, prefillMin: 0.05, prefillMax: 0.12 },
            'legend':   { size: 11, prefillMin: 0.03, prefillMax: 0.08 },
            'god':      { size: 12, prefillMin: 0.00, prefillMax: 0.05 }
        };

        let undoCount=3, hintCount=3, removeCount=1, jokerCount=1;
        let moveHistory = [], placedPiecesRegistry = [];
        let isRemoveMode = false;

        // DOM References
        const gameBoard = document.getElementById('game-board');
        const tray = document.getElementById('pieces-tray');
        const statusDiv = document.getElementById('status');
        const undoBtn = document.getElementById('undo-btn');
        const hintBtn = document.getElementById('hint-btn');
        const magnetBtn = document.getElementById('magnet-btn');
        const jokerBtn = document.getElementById('joker-btn');

        // --- INIT ---
        function initGame() {
            setDifficulty('med-hard', document.querySelector('.diff-btn.active'));
        }

        function setDifficulty(key, btn) {
            currentLevelKey = key;
            currentGridSize = LEVELS[key].size;
            document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
            if(btn) btn.classList.add('active');

            gameBoard.style.gridTemplateColumns = `repeat(${currentGridSize}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${currentGridSize}, 1fr)`;

            setTimeout(() => { updateCellSize(); generateLevel(); }, 50);
        }

        function updateCellSize() {
            renderBoard(false); 
            const firstCell = document.querySelector('.cell');
            if(firstCell) cellPixelSize = firstCell.getBoundingClientRect().width;
        }
        window.onresize = () => setTimeout(updateCellSize, 100);

        function renderBoard(isDummy = false) {
            gameBoard.innerHTML = '';
            
            if (boardState.length === 0 || boardState.length !== currentGridSize) {
                boardState = Array(currentGridSize).fill().map(() => Array(currentGridSize).fill(0));
            }

            for (let y = 0; y < currentGridSize; y++) {
                for (let x = 0; x < currentGridSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x; cell.dataset.y = y;
                    
                    // isDummy (sadece √∂l√ß√ºm i√ßin) deƒüilse eventleri ekle ve boya
                    if (!isDummy) {
                        cell.addEventListener('mousedown', () => handleBoardClick(x, y));
                        cell.addEventListener('touchstart', (e) => { e.preventDefault(); handleBoardClick(x, y); });
                    }

                    // Her durumda (Dummy veya Ger√ßek) tahtadaki veriyi √ßiz
                    // B√∂ylece boyut hesaplarken de dolu h√ºcreler √ßizilir, veri kaybolmaz.
                    const val = boardState[y][x];
                    if (val === 1) cell.classList.add('prefill');
                    else if (typeof val === 'string') {
                        if(val.includes('_LOCKED')) cell.classList.add('filled', val.split('_')[0], 'locked');
                        else cell.classList.add('filled', val);
                    }
                    
                    gameBoard.appendChild(cell);
                }
            }
        }

        function generateLevel() {
            // Reset
            undoCount=3; hintCount=3; removeCount=1; jokerCount=1;
            moveHistory=[]; placedPiecesRegistry=[]; isRemoveMode=false;
            gameBoard.classList.remove('remove-cursor'); magnetBtn.classList.remove('mode-active');
            updateButtons();
            statusDiv.innerText = `Oyun Ba≈üladƒ± (${currentGridSize}x${currentGridSize})`;

            // Grid Gen
            boardState = Array(currentGridSize).fill().map(() => Array(currentGridSize).fill(0));
            let virtualGrid = Array(currentGridSize).fill().map(() => Array(currentGridSize).fill(1));
            let remaining = currentGridSize * currentGridSize;
            tray.innerHTML = '';

            const lvl = LEVELS[currentLevelKey];
            let prefillTarget = Math.floor(remaining * (Math.random() * (lvl.prefillMax - lvl.prefillMin) + lvl.prefillMin));

            while(prefillTarget > 0 && remaining > 0) {
                let hx = Math.floor(Math.random() * currentGridSize);
                let hy = Math.floor(Math.random() * currentGridSize);
                if(boardState[hy][hx] === 0) {
                    boardState[hy][hx] = 1; virtualGrid[hy][hx] = 0;
                    remaining--; prefillTarget--;
                }
            }
            renderBoard();

            let failSafe = 0;
            while(remaining > 0 && failSafe < 3000) {
                failSafe++;
                let sx = Math.floor(Math.random() * currentGridSize);
                let sy = Math.floor(Math.random() * currentGridSize);
                if (virtualGrid[sy][sx] === 0) continue;

                let shapeType = (currentGridSize >= 9 && Math.random() > 0.4) ? 'blob' : 'rect';
                let maxPieceSize = Math.min(6, Math.floor(currentGridSize / 2) + 1);
                let size = Math.min(remaining, Math.floor(Math.random() * maxPieceSize) + 2);

                let shapeData = (shapeType === 'rect') 
                    ? growRectangle(virtualGrid, sx, sy, size)
                    : growBlob(virtualGrid, sx, sy, size);
                
                if (shapeData && shapeData.matrix.length > 0) {
                    createPieceForTray(shapeData);
                    let count = 0;
                    shapeData.matrix.forEach(r => r.forEach(v => { if(v) count++; }));
                    remaining -= count;
                }
            }
        }

        // --- SAVE / LOAD SYSTEM (JSON) ---
        function getGameState() {
            // T√ºm oyun durumunu bir obje olarak topla
            return {
                config: {
                    gridSize: currentGridSize,
                    levelKey: currentLevelKey
                },
                stats: {
                    undo: undoCount,
                    hint: hintCount,
                    remove: removeCount,
                    joker: jokerCount
                },
                board: boardState,
                // Tepsideki par√ßalarƒ± DOM'dan oku
                tray: Array.from(tray.children).map(el => el.shapeData),
                history: moveHistory,
                registry: placedPiecesRegistry,
                timestamp: new Date().toISOString()
            };
        }

        function restoreGameState(data) {
            try {
                // Konfig√ºrasyon
                currentGridSize = data.config.gridSize;
                currentLevelKey = data.config.levelKey;
                
                // CSS g√ºncelle (farklƒ± boyutta bir save y√ºklendiyse)
                gameBoard.style.gridTemplateColumns = `repeat(${currentGridSize}, 1fr)`;
                gameBoard.style.gridTemplateRows = `repeat(${currentGridSize}, 1fr)`;
                
                // Buton aktifliƒüini g√ºncelle
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                // O anki zorluƒüa uygun butonu bul (varsa)
                const btns = Array.from(document.querySelectorAll('.diff-btn'));
                const match = btns.find(b => b.textContent.includes(currentLevelKey)) || btns[2];
                if(match) match.classList.add('active');

                // Verileri y√ºkle
                undoCount = data.stats.undo;
                hintCount = data.stats.hint;
                removeCount = data.stats.remove;
                jokerCount = data.stats.joker;
                boardState = data.board;
                moveHistory = data.history || [];
                placedPiecesRegistry = data.registry || [];

                // Aray√ºz√º √ßiz
                updateCellSize(); // H√ºcre boyutunu yeniden hesapla
                setTimeout(() => {
                    renderBoard(); // Tahtayƒ± boya
                    tray.innerHTML = '';
                    data.tray.forEach(shape => createPieceForTray(shape)); // Tepsiyi doldur
                    updateButtons();
                    statusDiv.innerText = "Oyun Y√ºklendi!";
                    statusDiv.style.color = "#69f0ae";
                }, 100);

            } catch (e) {
                alert("Dosya bozuk veya uyumsuz!");
                console.error(e);
            }
        }

        function openSaveModal() {
            const json = JSON.stringify(getGameState(), null, 2);
            document.getElementById('export-area').value = json;
            document.getElementById('save-modal').style.display = 'flex';
        }

        function copyToClipboard() {
            const copyText = document.getElementById("export-area");
            copyText.select();
            document.execCommand("copy");
            alert("JSON panoya kopyalandƒ±!");
        }

        function downloadSaveFile() {
            const json = document.getElementById("export-area").value;
            const blob = new Blob([json], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `puzzle_save_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function openLoadModal() {
            document.getElementById('load-modal').style.display = 'flex';
            document.getElementById('import-area').value = "";
        }

        function closeModal(id) {
            document.getElementById(id).style.display = 'none';
        }

        function loadFromText() {
            const txt = document.getElementById('import-area').value;
            if(!txt) return;
            restoreGameState(JSON.parse(txt));
            closeModal('load-modal');
        }

        function handleFileUpload(input) {
            const file = input.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                restoreGameState(JSON.parse(e.target.result));
                closeModal('load-modal');
            };
            reader.readAsText(file);
            input.value = ""; // Reset input
        }

        // --- CORE LOGIC (Standard) ---
        function growRectangle(vGrid, sx, sy, targetSize) {
            let attempts = 0;
            while(attempts < 10) {
                attempts++;
                let w = Math.floor(Math.random() * targetSize) + 1;
                let h = Math.ceil(targetSize / w);
                if (w * h > targetSize + 2) continue; 
                if (sx + w > currentGridSize || sy + h > currentGridSize) continue;
                let fits = true;
                for(let y=0; y<h; y++) {
                    for(let x=0; x<w; x++) { if (vGrid[sy+y][sx+x] === 0) { fits = false; break; } }
                    if(!fits) break;
                }
                if(fits) {
                    for(let y=0; y<h; y++) for(let x=0; x<w; x++) vGrid[sy+y][sx+x] = 0;
                    let matrix = Array(h).fill().map(() => Array(w).fill(1));
                    return { matrix, color: getRandomColor(), targetX: sx, targetY: sy };
                }
            }
            return growBlob(vGrid, sx, sy, targetSize);
        }
        function growBlob(vGrid, sx, sy, targetSize) {
            let region = [{x: sx, y: sy}]; vGrid[sy][sx] = 0; let i = 0;
            while(region.length < targetSize && i < region.length) {
                let current = region[i];
                let dirs = [[0,1],[0,-1],[1,0],[-1,0]]; dirs.sort(() => Math.random() - 0.5);
                for(let d of dirs) {
                    let nx = current.x + d[1]; let ny = current.y + d[0];
                    if(nx>=0 && nx<currentGridSize && ny>=0 && ny<currentGridSize && vGrid[ny][nx]===1) {
                        vGrid[ny][nx] = 0; region.push({x: nx, y: ny});
                    }
                }
                i++;
            }
            let minX = Math.min(...region.map(c => c.x)); let minY = Math.min(...region.map(c => c.y));
            let width = Math.max(...region.map(c => c.x)) - minX + 1; let height = Math.max(...region.map(c => c.y)) - minY + 1;
            let matrix = Array(height).fill().map(() => Array(width).fill(0));
            region.forEach(c => matrix[c.y - minY][c.x - minX] = 1);
            return { matrix, color: getRandomColor(), targetX: minX, targetY: minY };
        }
        function getRandomColor() { return (currentLevelKey === 'god' && Math.random() > 0.8) ? 'c-god' : COLORS[Math.floor(Math.random() * COLORS.length)]; }

        // --- PIECE CREATION & DRAG ---
        function createPieceForTray(shape) {
            const container = document.createElement('div');
            container.classList.add('piece-preview');
            container.shapeData = shape;
            let scaleFactor = (currentGridSize > 9) ? 0.5 : 0.6;
            let pSize = Math.max(12, cellPixelSize * scaleFactor);
            container.style.gridTemplateColumns = `repeat(${shape.matrix[0].length}, ${pSize}px)`;
            shape.matrix.forEach(row => {
                row.forEach(val => {
                    const c = document.createElement('div');
                    if (val) {
                        c.classList.add('piece-cell', shape.color);
                        c.style.width = `${pSize}px`; c.style.height = `${pSize}px`;
                    } else { 
                        c.style.width = `${pSize}px`; c.style.height = `${pSize}px`; 
                    }
                    container.appendChild(c);
                });
            });
            container.addEventListener('mousedown', (e) => startDrag(e, container, shape));
            container.addEventListener('touchstart', (e) => startDrag(e, container, shape), {passive: false});
            tray.appendChild(container);
        }

        let dragEl=null, activeShape=null; const TOUCH_OFFSET_Y = 80;
        function startDrag(e, original, shape) {
            if(isRemoveMode) return;
            if(e.cancelable && e.type === 'touchmove') e.preventDefault();
            let clientX = e.clientX || e.touches[0].clientX; let clientY = e.clientY || e.touches[0].clientY;
            activeShape = shape; original.style.opacity = '0.3';
            dragEl = original.cloneNode(true); dragEl.classList.add('dragging');
            const cols = shape.matrix[0].length;
            dragEl.style.gridTemplateColumns = `repeat(${cols}, ${cellPixelSize}px)`;
            Array.from(dragEl.children).forEach(c => { c.style.width = `${cellPixelSize}px`; c.style.height = `${cellPixelSize}px`; });
            document.body.appendChild(dragEl); moveAt(clientX, clientY);
            function moveAt(x, y) { dragEl.style.left = (x - (dragEl.offsetWidth / 2)) + 'px'; dragEl.style.top = (y - (dragEl.offsetHeight / 2) - TOUCH_OFFSET_Y) + 'px'; }
            let lastBestCoords = null;
            function onMove(ev) {
                ev.preventDefault(); let cx = ev.clientX || ev.touches[0].clientX; let cy = ev.clientY || ev.touches[0].clientY; moveAt(cx, cy);
                const rect = dragEl.getBoundingClientRect();
                lastBestCoords = findBestPlacement(rect.left + rect.width/2, rect.top + rect.height/2, activeShape);
                if (lastBestCoords) showPreview(lastBestCoords.x, lastBestCoords.y, activeShape); else clearPreview();
            }
            function onEnd(ev) {
                document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onEnd);
                document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', onEnd);
                clearPreview();
                if (lastBestCoords) {
                    moveHistory.push({ boardState: JSON.parse(JSON.stringify(boardState)), registry: JSON.parse(JSON.stringify(placedPiecesRegistry)), pieceShape: activeShape });
                    updateButtons(); placeShape(lastBestCoords.x, lastBestCoords.y, activeShape, false);
                    original.remove(); checkWin();
                } else { original.style.opacity = '1'; }
                if(dragEl) dragEl.remove();
            }
            document.addEventListener('mousemove', onMove, {passive: false}); document.addEventListener('mouseup', onEnd);
            document.addEventListener('touchmove', onMove, {passive: false}); document.addEventListener('touchend', onEnd);
        }

        function placeShape(gx, gy, shape, isLocked) {
            let placedCells = [];
            shape.matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if(val) {
                        let finalVal = shape.color; if(isLocked) finalVal += "_LOCKED";
                        boardState[gy+y][gx+x] = finalVal; placedCells.push({x: gx+x, y: gy+y});
                        const cell = document.querySelector(`.cell[data-x="${gx+x}"][data-y="${gy+y}"]`);
                        if(cell) {
                            cell.className = `cell filled ${shape.color} ${isLocked?'locked':''}`;
                            cell.style.transform = "scale(0.5)"; setTimeout(() => cell.style.transform = "scale(1)", 150);
                        }
                    }
                });
            });
            if(!isLocked) placedPiecesRegistry.push({ cells: placedCells, shapeData: shape });
        }

        function findBestPlacement(pixelX, pixelY, shape) {
            const boardRect = gameBoard.getBoundingClientRect();
            const relX = pixelX - boardRect.left; const relY = pixelY - boardRect.top;
            const centerGx = Math.round((relX / cellPixelSize) - 0.5); const centerGy = Math.round((relY / cellPixelSize) - 0.5);
            const offsetX = Math.floor(shape.matrix[0].length / 2); const offsetY = Math.floor(shape.matrix.length / 2);
            let bestX = -1; let bestY = -1; let minD = Infinity;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    let csx = (centerGx + dx) - offsetX; let csy = (centerGy + dy) - offsetY;
                    if (isValid(csx, csy, shape)) {
                        const dist = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                        if (dist < minD) { minD = dist; bestX = csx; bestY = csy; }
                    }
                }
            }
            if (bestX !== -1) return { x: bestX, y: bestY }; return null;
        }
        function isValid(sx, sy, shape) {
            for(let y=0; y<shape.matrix.length; y++) for(let x=0; x<shape.matrix[0].length; x++) {
                if(shape.matrix[y][x]===1) {
                    let tx = sx + x; let ty = sy + y;
                    if(tx < 0 || tx >= currentGridSize || ty < 0 || ty >= currentGridSize) return false;
                    if(boardState[ty][tx] !== 0) return false;
                }
            } return true;
        }
        function showPreview(sx, sy, shape) {
            clearPreview();
            shape.matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if(val) {
                        const cell = document.querySelector(`.cell[data-x="${sx+x}"][data-y="${sy+y}"]`);
                        if(cell) cell.classList.add('preview');
                    }
                });
            });
        }
        function clearPreview() { document.querySelectorAll('.cell.preview').forEach(el => el.classList.remove('preview')); }

        function toggleRemoveMode() {
            if(removeCount<=0) return; isRemoveMode = !isRemoveMode;
            if(isRemoveMode) { magnetBtn.classList.add('mode-active'); gameBoard.classList.add('remove-cursor'); statusDiv.innerText="S√∂kmek i√ßin dokun."; }
            else { magnetBtn.classList.remove('mode-active'); gameBoard.classList.remove('remove-cursor'); statusDiv.innerText="Devam et."; }
        }
        function handleBoardClick(x, y) {
            if(!isRemoveMode) return;
            const idx = placedPiecesRegistry.findIndex(p => p.cells.some(c => c.x===x && c.y===y));
            if(idx > -1) {
                const rec = placedPiecesRegistry[idx];
                rec.cells.forEach(c => {
                    boardState[c.y][c.x] = 0;
                    const el = document.querySelector(`.cell[data-x="${c.x}"][data-y="${c.y}"]`);
                    if(el) { el.className='cell'; el.style.transform="scale(0.1)"; setTimeout(()=>el.style.transform="scale(1)",200); }
                });
                createPieceForTray(rec.shapeData);
                placedPiecesRegistry.splice(idx, 1);
                isRemoveMode=false; removeCount--; updateButtons();
                magnetBtn.classList.remove('mode-active'); gameBoard.classList.remove('remove-cursor');
                moveHistory=[]; undoBtn.disabled=true;
            }
        }
        function undoMove() {
            if(undoCount>0 && moveHistory.length>0) {
                const last = moveHistory.pop();
                boardState = JSON.parse(JSON.stringify(last.boardState));
                placedPiecesRegistry = JSON.parse(JSON.stringify(last.registry));
                renderBoard(); createPieceForTray(last.pieceShape);
                undoCount--; updateButtons();
            }
        }
        function useHint() {
            if(hintCount<=0) return;
            const pieces = Array.from(tray.children); if(pieces.length===0) return;
            let best=null, bShape=null;
            for(let p of pieces) {
                if(p.shapeData.targetX===-1) continue;
                if(canPlacePerfectly(p.shapeData)) { best=p; bShape=p.shapeData; break; }
            }
            if(best) {
                placeShape(bShape.targetX, bShape.targetY, bShape, true);
                best.remove(); hintCount--; updateButtons(); checkWin();
            } else { statusDiv.innerText="Uygun par√ßa yok."; statusDiv.style.color="red"; }
        }
        function canPlacePerfectly(s) {
            for(let y=0; y<s.matrix.length; y++) for(let x=0; x<s.matrix[0].length; x++) {
                if(s.matrix[y][x]===1) { if(boardState[s.targetY+y][s.targetX+x]!==0) return false; }
            } return true;
        }
        function updateButtons() {
            undoBtn.innerText=`‚Ü∫ (${undoCount})`; undoBtn.disabled=(undoCount===0||moveHistory.length===0);
            hintBtn.innerText=`üí° (${hintCount})`; hintBtn.disabled=(hintCount===0);
            magnetBtn.innerText=`üß≤ (${removeCount})`; magnetBtn.disabled=(removeCount===0);
            jokerBtn.innerText=`‚òÖ (${jokerCount})`; jokerBtn.disabled=(jokerCount===0);
        }
        function checkWin() {
            if(boardState.every(r=>r.every(v=>v!==0))) {
                statusDiv.innerHTML="<span style='color:#69F0AE; font-weight:bold'>üèÜ TEBRƒ∞KLER!</span>";
                triggerConfetti();
            }
        }
        function triggerConfetti() {
             const duration = 3000; const end = Date.now() + duration;
            const canvas = document.createElement('canvas');
            canvas.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999";
            document.body.appendChild(canvas);
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            const colors = ['#ff5252', '#448aff', '#69f0ae', '#e040fb', '#ffd740'];
            const particles = Array.from({length: 150}, () => ({
                x: Math.random() * canvas.width, y: Math.random() * canvas.height - canvas.height,
                w: Math.random() * 10 + 5, h: Math.random() * 10 + 5, color: colors[Math.floor(Math.random() * colors.length)],
                vy: Math.random() * 3 + 2, vx: Math.random() * 2 - 1, rot: Math.random() * 360, rotSpeed: Math.random() * 10 - 5
            }));
            function frame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                let active = 0;
                particles.forEach(p => {
                    p.y += p.vy; p.x += p.vx; p.rot += p.rotSpeed;
                    ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rot * Math.PI/180);
                    ctx.fillStyle = p.color; ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h); ctx.restore();
                    if (p.y < canvas.height) active++;
                });
                if (Date.now() < end || active > 0) requestAnimationFrame(frame); else canvas.remove();
            }
            frame();
        }

        // JOKER 
        let jokerSelection=[];
        function openJokerModal() { if(jokerCount>0) { document.getElementById('joker-modal').style.display='flex'; jokerSelection=Array(5).fill().map(()=>Array(5).fill(0)); renderJokerGrid(); } }
        function closeJokerModal() { document.getElementById('joker-modal').style.display='none'; }
        function renderJokerGrid() {
            const el = document.getElementById('joker-grid'); el.innerHTML='';
            for(let y=0; y<5; y++) for(let x=0; x<5; x++) {
                const d = document.createElement('div'); d.className = 'j-cell ' + (jokerSelection[y][x]?'selected':'');
                d.onclick=()=>{ 
                    if(jokerSelection[y][x]) jokerSelection[y][x]=0; 
                    else if(jokerSelection.flat().reduce((a,b)=>a+b,0)<5) jokerSelection[y][x]=1; 
                    renderJokerGrid(); 
                };
                el.appendChild(d);
            }
        }
        function createJokerPiece() {
            if(!checkConn(jokerSelection)) { document.getElementById('joker-status').innerText="Baƒülantƒ±sƒ±z!"; return; }
            const shape = cropMat(jokerSelection); shape.color = "#e040fb"; shape.targetX=-1;
            createPieceForTray(shape); jokerCount--; updateButtons(); closeModal('joker-modal');
        }
        function checkConn(m) {
            let pts=[], total=0; for(let y=0;y<5;y++)for(let x=0;x<5;x++)if(m[y][x]){pts.push({x,y});total++;}
            if(total===0)return false; let q=[pts[0]],seen=new Set([pts[0].x+','+pts[0].y]),count=0;
            while(q.length){ let c=q.shift(); count++; [[0,1],[0,-1],[1,0],[-1,0]].forEach(d=>{ let nx=c.x+d[0],ny=c.y+d[1]; if(nx>=0&&nx<5&&ny>=0&&ny<5&&m[ny][nx]&&!seen.has(nx+','+ny)){seen.add(nx+','+ny);q.push({x:nx,y:ny});} }); }
            return count===total;
        }
        function cropMat(m) {
            let minX=5, maxX=-1, minY=5, maxY=-1; for(let y=0;y<5;y++)for(let x=0;x<5;x++)if(m[y][x]){minX=Math.min(minX,x);maxX=Math.max(maxX,x);minY=Math.min(minY,y);maxY=Math.max(maxY,y);}
            let h=maxY-minY+1, w=maxX-minX+1, nm=Array(h).fill().map(()=>Array(w).fill(0));
            for(let y=0;y<h;y++)for(let x=0;x<w;x++)nm[y][x]=m[minY+y][minX+x]; return {matrix:nm};
        }

        initGame();
    </script>
</body>
</html>
